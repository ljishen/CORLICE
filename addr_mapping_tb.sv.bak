`define ADDR_WIDTH 64

typedef bit [`ADDR_WIDTH-1:0] addr_bits;

module default_hash ();
   int lg_num_buckets;
   addr_bits coe_a, coe_b;

   function addr_bits hash(input addr_bits sva);
      bit [`ADDR_WIDTH/2-1:0] upper, lower, mask;
   
      upper = sva >> (`ADDR_WIDTH / 2);
      mask = (1 << (`ADDR_WIDTH / 2)) - 1;
      lower = sva & mask;

      hash = (upper * coe_a + lower * coe_b) >> (`ADDR_WIDTH - lg_num_buckets);
   endfunction

   task update(input int num_buckets);
      static int lg_val = -1;
      while (num_buckets > 0) begin
         num_buckets = num_buckets >> 1;
         lg_val = lg_val + 1;
      end
      lg_num_buckets = lg_val;

      coe_a = {$urandom, $urandom};
      coe_b = {$urandom, $urandom};
   endtask
endmodule

module addr_mapping_tb();

   addr_bits val;

   task print;
      begin
         val = dh.hash(`ADDR_WIDTH'h aaaaaaaabbbbbbbb);

         $display("sva is %h", dh.hash.sva);
         $display("upper is %h", dh.hash.upper);
         $display("lower is %h", dh.hash.lower);
         $display("lg_num_buckets is %d", dh.lg_num_buckets);
         $display("coe_a is %h", dh.coe_a);
         $display("coe_b is %h", dh.coe_b);
         $display("val is %d", val);
      end
   endtask

   default_hash dh();
   
   int num_buckets;
   always @(num_buckets) begin
      dh.update(num_buckets);
      $display("num_buckets is %d", num_buckets);
      
      update2(num_buckets);
      $display("lg_val is %d", lg_val);
   end
   
   int lg_val;
   task update2(input int num_buckets);
      automatic int val = -1;
      while (num_buckets > 0) begin
         num_buckets = num_buckets >> 1;
         val = val + 1;
      end
      lg_val = val;
   endtask
   

   initial
   begin
      num_buckets = 4; #1
      print();   #1
      
      num_buckets = 8; #1
      print();    #1
      
      num_buckets = 16; #1
      print();
   end

endmodule